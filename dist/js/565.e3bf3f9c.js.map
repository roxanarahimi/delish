{"version":3,"file":"js/565.e3bf3f9c.js","mappings":"sPAEO,MAAMA,EAAW,CAACC,EAAIC,KAC3B,IAAIC,EAEJ,OAAO,YAAaC,GAClB,MAAMC,EAAUC,KACZH,GACFI,aAAaJ,GAEfA,EAAUK,YAAW,KACnBP,EAAGQ,MAAMJ,EAASD,GAClBD,EAAU,OACTD,KAIMQ,EAAyBC,GAC/BA,GAAmC,oBAAlBA,EAAOC,OAGtBD,EAAOC,OAAO,GAAGC,cAAgBF,EAAOG,MAAM,GAF5CH,EAKEI,EAAc,CAACC,EAASC,EAAgBC,KACnD,IAAK,MAAMC,KAAOD,EAAO,CACvB,MAAME,EAAgB,MAAQV,EAAsBS,GAChDH,EAAQI,IACVC,EAAAA,EAAAA,KACE,IAAMH,EAAMC,KACZ,CAACG,EAAQC,KACPP,EAAQI,GAAeE,EAAQC,MAG1BN,EAAeG,KACxBC,EAAAA,EAAAA,KACE,IAAMH,EAAMC,KACXG,IACCL,EAAeG,GAAeE,QAO3BE,EAAeC,IAC1B,MAAMC,EAAS,GACf,IAAK,MAAMC,KAAYF,EACrB,GACEE,EAASC,WAAW,QACnBD,EAASC,WAAW,aACR,YAAbD,EACA,CACA,MAAME,EAAYF,EAASb,MAAM,GAAGgB,oBACpCJ,EAAOG,GAAaJ,EAAaE,GAGrC,OAAOD,GAGIK,EAAmBC,UAC9B,MAAMC,QAAgBC,QAAQC,IAAI,CAChC,mCACA,kCACA,4CAGKC,EAAKC,QAAQC,UAAUC,YAE9BH,EAAKC,QAAQG,aAAa,CACxBC,cAAeR,EAAQ,GAAGS,QAC1BC,QAASV,EAAQ,GAAGS,QACpBE,UAAWX,EAAQ,GAAGS,WAWbG,EAAyBC,IACpC,MAAMC,GAAUC,EAAAA,EAAAA,KAAI,IAClBC,QAAQC,KAAM,UAASJ,+CAEnBK,EAAU,IAAI/C,IAAS2C,EAAQK,SAAShD,GAK9C,OAHA+C,EAAQJ,QAAUA,GAClBM,EAAAA,EAAAA,IAAQP,EAAYK,GAEbA,GAUIG,EAAuB,CAACH,EAASI,IAC3CJ,EAAQJ,QAAQK,MAAQG,EAEdC,EACM,kBAATC,MAAqBA,KAAKA,OAASA,MAAQA,MAChC,kBAAXC,EAAAA,GAAuBA,EAAAA,EAAOA,SAAWA,EAAAA,GAAUA,EAAAA,QAC3DC,EAEWC,EAAqB,mBC9GrB1C,EAAQ,CACnB2C,QAAS,CACPC,KAAMC,OACNrB,QAAS,KAAM,MAINsB,EAAS9C,IACb,CAAE2C,QAAS3C,EAAM2C,QAAS7C,QAAS,KCL/BE,EAAQ,IAChB+C,EACHC,KAAM,CACJJ,KAAMK,OACNzB,QAAS,eAEX0B,YAAa,CACXN,KAAMK,OACNzB,QAAS,MAEX2B,KAAM,CACJP,KAAMK,OACNG,QAAQ,EACR5B,aAASiB,GAEXY,UAAW,CACTT,KAAMK,OACNG,QAAQ,EACR5B,aAASiB,GAEXa,QAAS,CACPV,KAAMW,QACNH,QAAQ,EACR5B,SAAS,IAIAsB,EAAQ,CAAC9C,EAAOwD,EAAYrE,KACvC,MAAMsE,GAAWC,EAAAA,EAAAA,IAAO,YAClBC,GAAcD,EAAAA,EAAAA,IAAO,gBAEzBf,QAASiB,EACT9D,QAAS+D,GACPC,EAAe9D,GAEb2C,EAAU,IACXiB,EACHV,YAAalD,EAAMkD,YACnBF,KAAMhD,EAAMgD,MAGRe,EAAe,IAAMN,EAAS,CAAEO,cAAeR,EAAWtB,QAC1D+B,EAAkB,IACtBN,EAAY,CAAEK,cAAeR,EAAWtB,QAEpCpC,EAAU,IACX+D,EACHK,eAAeC,EAAKC,GAClB,MAAMC,EAAqBjF,KAAKkF,QAAQN,cAAcK,mBACtDA,EAAmBE,kBAAkBH,GAAKI,eAAeL,IAE3DM,UACER,IACIjE,EAAMsD,SACRS,KAGJW,eACET,IACIjE,EAAMsD,SACRS,KAGJY,WAAWC,GACLpB,EAAWtB,QACT0C,EACFb,IAEAE,MAINY,WAAU,cAAEb,IACVR,EAAWtB,MAAM2C,UAAUb,IAE7Bc,aAAY,cAAEd,IACZR,EAAWtB,MAAM4C,YAAYd,IAE/Be,gBACE,MAAMC,EAAUxB,EAAWtB,MAAQsB,EAAWtB,MAAM+C,aAAe,KAC/DD,GACFA,EAAQD,iBAGZG,cACE,MAAMC,EAAQ3B,EAAWtB,MAAQsB,EAAWtB,MAAMkD,WAAa,KAC3DD,GACFA,EAAMD,eAGVG,kBAAkBnD,GAMhB/C,EAAQmG,KAAK,iBAAkBpD,KAenC,OAXAC,EAAAA,EAAAA,IAAQ,YAAarC,EAAQ+E,YAC7B1C,EAAAA,EAAAA,IAAQ,cAAerC,EAAQgF,cAC/B3C,EAAAA,EAAAA,IAAQ,gBAAiBrC,EAAQiF,gBACjC5C,EAAAA,EAAAA,IAAQ,cAAerC,EAAQoF,cAE/BK,EAAAA,EAAAA,KAAY,KACVzF,EAAQoF,cACRpF,EAAQiF,gBACRd,OAGK,CAAEtB,UAAS7C,YAGP0F,EAAS,CAACC,EAAOC,KAC5B,GAAID,GAASC,EAAMlE,QACjB,OAAOmE,EAAAA,EAAAA,GAAE,MAAO,CAAEC,MAAO,CAAEC,QAAS,SAAYH,EAAMlE,YCrH7CxB,EAAQ,IAChB+C,EACH+C,YAAa,CACXlD,KAAMW,QACN/B,SAAS,GAEXuE,oBAAqB,CACnBnD,KAAMW,QACN/B,SAAS,ICHAxB,EAAQ,IAChBgG,KACAC,EACHC,OAAQ,CACNtD,KAAMW,QACNH,QAAQ,EACR5B,SAAS,GAEX2E,MAAO,CACLvD,KAAMK,OACNG,QAAQ,EACR5B,QAAS,WAEX4E,OAAQ,CACNxD,KAAMyD,OACNjD,QAAQ,EACR5B,QAAS,GAEX8E,QAAS,CACP1D,KAAMyD,OACNjD,QAAQ,EACR5B,QAAS,GAEX+E,QAAS,CACP3D,KAAMK,OACNG,QAAQ,EACR5B,QAAS,SAEXgF,SAAU,CACR5D,KAAMK,OACNG,QAAQ,EACR5B,QAAS,SAEXiF,UAAW,CACT7D,KAAMK,OACNG,QAAQ,EACR5B,QAAS,MAEXkF,WAAY,CACV9D,KAAMK,OACNG,QAAQ,EACR5B,QAAS,MAEXmF,KAAM,CACJ/D,KAAMW,QACNH,QAAQ,EACR5B,SAAS,GAEXoF,UAAW,CACThE,KAAMK,OACNG,QAAQ,EACR5B,QAAS,WAEXqF,YAAa,CACXjE,KAAMyD,OACNjD,QAAQ,EACR5B,QAAS,IAEXsF,SAAU,CACRlE,KAAMK,OACNG,QAAQ,EACR5B,QAAS,WAEXuF,UAAW,CACTnE,KAAMK,OACNG,QAAQ,EACR5B,QAAS,OCvEAxB,EAAQ,IAChBgH,EACHC,OAAQ,CACNrE,KAAM,CAACC,OAAQqE,OACf9D,QAAQ,EACR5B,QAAS,MAKX2F,OAAQ,CACNvE,KAAMyD,OACN7E,QAAS,OCXN,MAAMxB,EAAQ,IAChB+C,EACHqE,SAAU,CACRxE,KAAMK,OACNzB,QAAS,aAIAsB,EAAQ,CAAC9C,EAAOwD,KAC3B,MACEb,QAASiB,EACT9D,QAAS+D,GACPC,EAAe9D,GACb2C,EAAU,IACXiB,EACHwD,SAAUpH,EAAMoH,UAGZtH,EAAU,IACX+D,EACHwD,YAAYD,GACN5D,EAAWtB,OACbsB,EAAWtB,MAAMmF,YAAYD,KAWnC,OANA7B,EAAAA,EAAAA,KAAY,KACN/B,EAAWtB,OACbsB,EAAWtB,MAAMoF,YAId,CAAE3E,UAAS7C,YAGP0F,EAAUE,GACjBA,EAAMlE,SACDmE,EAAAA,EAAAA,GAAE,MAAO,CAAE7D,IAAK,QAAU4D,EAAMlE,WAElC,KC7BG+B,QAKAA,QCdFA,QAIAA,QAIAA,QAIAA,QCRAA,QAIAA,QAIAA,QCdH,MAAMvD,EAAQ,IAChBgG,GAGQlD,EAAQ,CAAC9C,EAAOwD,EAAYrE,KACvC,MAAQwD,QAAS4E,EAAczH,QAAS0H,GAAiBC,EACvDzH,EACAwD,EACArE,GAGIwD,EAAU,IACX4E,GAGCzH,EAAU,IACX0H,EACH/D,SAASiE,GACPlE,EAAWtB,MAAMuB,SAASiE,EAAM1D,gBAElCL,YAAY+D,GACVlE,EAAWtB,MAAMyB,YAAY+D,EAAM1D,iBAOvC,OAHA7B,EAAAA,EAAAA,IAAQ,WAAYrC,EAAQ2D,WAC5BtB,EAAAA,EAAAA,IAAQ,cAAerC,EAAQ6D,aAExB,CAAEhB,UAAS7C,YC1Bb,MAAME,EAAQ,IAChB2H,EACHC,QAAS,CACPhF,KAAM,CAACC,OAAQqE,OACf1F,QAAS,KAAM,MAINsB,EAAQ,CAAC9C,EAAOwD,KAC3B,MAAQb,QAAS4E,EAAczH,QAAS+H,GAAsBC,EAC5D9H,EACAwD,GAGIb,EAAU,IACX4E,KACAvH,GAGCF,EAAU,IACX+H,EACHE,WAAW3H,GACToD,EAAWtB,MAAM8F,cACjBxE,EAAWtB,MAAM+F,QAAQ7H,IAE3B8H,iBACE,OAAO1E,EAAWtB,MAAMiG,aAE1BC,YACE,OAAO5E,EAAWtB,MAAMkG,cAI5B,MAAO,CAAEzF,UAAS7C,YC3BpB,MAAe,C,MACbE,EACA8C,MAAM9C,EAAOb,GACX,MAAMqE,GAAa1B,EAAAA,EAAAA,IAAI,IACjB2D,GAAQ3D,EAAAA,EAAAA,KAAI,GAEZuG,GAAmB3E,EAAAA,EAAAA,IAAOhB,GAC1Be,GAAWC,EAAAA,EAAAA,IAAO,aAElB,QAAE5D,EAAF,QAAW6C,GAAY2F,EAAatI,EAAOwD,GAqBjD,OAnBA+E,EAAAA,EAAAA,KAAUzH,UACR,MAAM,QAAE0H,EAAF,SAAWC,GAAaJ,EAC1B/F,EAAiBoG,QACX,8BAEVlF,EAAWtB,MAAQsG,EAAQxI,EAAM4H,QAASjF,GAE1C,MAAMgG,EAAYrI,EAAYnB,EAAQyJ,OACtCH,EAASI,GAAGrF,EAAWtB,MAAOyG,GAE9B9I,EAAYC,EAAS0D,EAAWtB,MAAOlC,GACvCyD,EAAS,IACJzD,KACAF,EACHkE,cAAeR,EAAWtB,QAE5BuD,EAAMvD,OAAQ,GACd4G,EAAAA,EAAAA,KAAS,IAAM3J,EAAQmG,KAAK,QAAS9B,EAAWtB,YAE3C,CAAEuD,QAAOzB,cAAeR,IAEjCgC,SACE,OAAOA,EAAOpG,KAAKqG,MAAOrG,KAAK2J,S,sCC1C5B,MAAM/I,EAAQ,IAChBgG,EACHhD,KAAM,CACJJ,KAAMK,OACNzB,QAAS,YAEX8E,QAAS,CACP1D,KAAMyD,OACNjD,QAAQ,EACR5B,QAAS,GAEXwH,OAAQ,CACNpG,KAAMyD,OACN7E,QAAS,GAEXyH,SAAU,CACRrG,KAAMyD,OACN7E,QAAS,KAEX0H,OAAQ,CACNtG,KAAMW,QACN/B,SAAS,GAEX2H,QAAS,CACPvG,KAAMyD,OACN7E,QAAS,GAEX4H,QAAS,CACPxG,KAAMyD,OACN7E,aAASiB,IAIAK,EAAQ,CAAC9C,EAAOwD,EAAYrE,KACvC,MAAQwD,QAAS4E,EAAczH,QAAS0H,GAAiBC,EACvDzH,EACAwD,EACArE,GAEIwD,EAAU,IACX4E,EACHvE,KAAMhD,EAAMgD,KACZsD,QAAStG,EAAMsG,QACf0C,OAAQhJ,EAAMgJ,OACdC,SAAUjJ,EAAMiJ,SAChBC,OAAQlJ,EAAMkJ,OACdC,QAASnJ,EAAMmJ,QACfC,QAASpJ,EAAMoJ,SAEjB,MAAO,CAAEzG,UAAS7C,QAAS,IAAK0H,KCnD3B,MAAMxH,EAAQ,CACnByB,QAAS,CACPmB,KAAMK,OACNG,QAAQ,EACR5B,QAAS,MAEXD,cAAe,CACbqB,KAAMK,OACNG,QAAQ,EACR5B,QAAS,MAEX6H,SAAU,CACRzG,KAAM,CAACC,OAAQqE,OACf9D,QAAQ,EACR5B,QAAS,MAEX8H,WAAY,CACV1G,KAAM,CAACC,OAAQqE,OACf9D,QAAQ,EACR5B,QAAS,MAEX+H,YAAa,CACX3G,KAAM,CAACC,OAAQqE,OACf9D,QAAQ,EACR5B,QAAS,IAAM,CAAC,EAAG,IAErBgI,cAAe,CACb5G,KAAM,CAACC,OAAQqE,OACf9D,QAAQ,EACR5B,QAAS,IAAM,CAAC,EAAG,IAErBE,UAAW,CACTkB,KAAMK,OACNG,QAAQ,EACR5B,QAAS,MAEXiI,gBAAiB,CACf7G,KAAMK,OACNG,QAAQ,EACR5B,QAAS,MAEXkI,WAAY,CACV9G,KAAM,CAACC,OAAQqE,OACf9D,QAAQ,EACR5B,QAAS,MAEXmI,aAAc,CACZ/G,KAAM,CAACC,OAAQqE,OACf9D,QAAQ,EACR5B,QAAS,MAEXoI,MAAO,CACLhH,KAAM,CAACC,OAAQqE,OACf9D,QAAQ,EACR5B,QAAS,IAAM,CAAC,EAAG,IAErBuF,UAAW,CACTnE,KAAMK,OACNG,QAAQ,EACR5B,QAAS,IAEXmB,QAAS,CACPC,KAAMC,OACNO,QAAQ,EACR5B,QAAS,KAAM,MCvCT+B,QAIAA,QCZV,ICSA,EAAe,CACbsG,MAAO,CAAC,QAAS,cAAe,gBAAiB,iBACjD7J,MAAO,IACF+C,EAIH+G,OAAQ,CACNlH,KAAM,CAACC,OAAQqE,OACf1F,QAAS,IAAM,CAAC,EAAG,IAKrBuI,OAAQ,CACNnH,KAAM,CAACsE,MAAOrE,QACdrB,aAASiB,GAKXuH,UAAW,CACTpH,KAAM,CAACsE,MAAOrE,QACdrB,aAASiB,GAKXwH,KAAM,CACJrH,KAAMyD,OACN7E,QAAS,GAKX2H,QAAS,CACPvG,KAAMyD,OACN7E,aAASiB,GAKX2G,QAAS,CACPxG,KAAMyD,OACN7E,aAASiB,GAKXyH,mBAAoB,CAClBtH,KAAMsE,MACN1F,aAASiB,GAKX0H,eAAgB,CACdvH,KAAMsE,MACN1F,aAASiB,GAKX2H,QAAS,CACPxH,KAAMsE,MACN1F,aAASiB,GAKX4H,cAAe,CACbzH,KAAMW,QACN/B,SAAS,GAQX8I,IAAK,CACH1H,KAAM,CAACK,OAAQJ,QACfrB,QAAS,YAEX+I,mBAAoB,CAClB3H,KAAMyD,OACN7E,aAASiB,GAEX+H,QAAS,CACP5H,KAAMW,QACN/B,aAASiB,GAEXgI,oBAAqB,CACnB7H,KAAMyD,OACN7E,aAASiB,GAEXiI,gBAAiB,CACf9H,KAAMyD,OACN7E,aAASiB,GAEXkI,cAAe,CACb/H,KAAMyD,OACN7E,aAASiB,GAEXmI,cAAe,CACbhI,KAAMW,QACN/B,aAASiB,GAEXoI,uBAAwB,CACtBjI,KAAMyD,OACN7E,aAASiB,GAEXqI,cAAe,CACblI,KAAMW,QACN/B,aAASiB,GAEXsI,oBAAqB,CACnBnI,KAAMW,QACN/B,aAASiB,GAEXuI,qBAAsB,CACpBpI,KAAMW,QACN/B,SAAS,GAEX6G,iBAAkB,CAChBzF,KAAMW,QACN/B,SAAS,IAGbsB,MAAM9C,EAAOb,GACX,MAAM8L,GAAOnJ,EAAAA,EAAAA,IAAI,MACXoJ,GAAYC,EAAAA,EAAAA,IAAS,CACzB1F,OAAO,EACPjC,WAAY,GACZ4H,YAAa,GACbC,gBAAiB,MAEX1I,QAASiB,GAAqBE,EAAe9D,GAC/C2C,EAAU,IACXiB,EACHuF,QAASnJ,EAAMmJ,QACfC,QAASpJ,EAAMoJ,QACfY,UAAWhK,EAAMgK,UACjBO,mBAAoBvK,EAAMuK,mBAC1BF,cAAerK,EAAMqK,cACrBC,IAAKtK,EAAMsK,IACXR,OAAQ9J,EAAM8J,OACdG,KAAMjK,EAAMiK,KACZO,QAASxK,EAAMwK,QACfC,oBAAqBzK,EAAMyK,oBAC3BC,gBAAiB1K,EAAM0K,gBACvBC,cAAe3K,EAAM2K,cACrBC,cAAe5K,EAAM4K,cACrBC,uBAAwB7K,EAAM6K,uBAC9BC,cAAe9K,EAAM8K,cACrBC,oBAAqB/K,EAAM+K,qBAGvBtH,EAAW9B,EAAsB,YACjCgC,EAAchC,EAAsB,eACpC2J,EAAkB3J,EAAsB,mBACxC4J,EAAuB5J,EAAsB,yBACnDQ,EAAAA,EAAAA,IAAQO,EAAoB1C,EAAMqI,kBAElC,MAAMmD,EAAgB,CACpBC,iBAKEtM,EAAQmG,KAAK,cAAe4F,EAAU1H,WAAWkI,WAKjDvM,EAAQmG,KAAK,gBAAiB4F,EAAU1H,WAAWmI,aAMnDxM,EAAQmG,KAAK,gBAAiB4F,EAAU1H,WAAW4E,cAErDwD,kBAAkBC,GAChB,MAAMnE,EAAQwD,EAAUG,gBAAgBS,MAAMC,GAAMA,EAAE5I,OAAS0I,EAAE1I,OAC7DuE,GACFA,EAAMrC,mBAAkB,IAG5B2G,qBAAqBH,GACnB,MAAMnE,EAAQwD,EAAUG,gBAAgBS,MAAMC,GAAMA,EAAE5I,OAAS0I,EAAE1I,OAC7DuE,GACFA,EAAMrC,mBAAkB,MAK9BkD,EAAAA,EAAAA,KAAUzH,UACJd,EAAMqI,mBACR/F,EAAiBoG,EAAIpG,EAAiBoG,SAAY,oCAEpD,MAAM,IACJuD,EADI,IAEJC,EAFI,KAGJhL,EAHI,aAIJiL,EAJI,OAKJlF,EALI,SAMJwB,GACEzI,EAAMqI,iBACN/F,EAAiBoG,QACX,8BAEV,IACE/F,EAAQyJ,sBAAyBzJ,EAAQyJ,iBACzC,MAAOC,GACPtK,QAAQsK,MACL,yEAAwEA,EAAMC,iBAI7EzL,EAAiBK,GAEvB,MAAMqL,EACkB,iBAAf5J,EAAQ2H,IAAkB4B,EAAIvJ,EAAQ2H,KAAO3H,EAAQ2H,IAC9D3H,EAAQ2H,IAAMiC,GAAcL,EAAIM,SAEhC,MAAM1M,EAAU,CACd2D,SAASiE,GACP,QAAwBjF,IAApBiF,EAAMrE,UACR,QAA+BZ,IAA3ByI,EAAUuB,aACZvB,EAAUE,YAAYsB,KAAKhF,OACtB,CACL,MAAMiF,EAAQzB,EAAUG,gBAAgBS,MACrCC,GACCA,EAAE/H,cAAc4I,cAChBlF,EAAM1D,cAAc4I,cAEnBD,IACHzB,EAAUuB,aAAahJ,SAASiE,GAChCwD,EAAUG,gBAAgBqB,KAAKhF,KAIf,IAAlBA,EAAMpE,SACR4H,EAAU1H,WAAWC,SAASiE,EAAM1D,gBAGxCL,YAAY+D,QACcjF,IAApBiF,EAAMrE,iBACuBZ,IAA3ByI,EAAUuB,aACZvB,EAAUE,YAAcF,EAAUE,YAAYyB,QAC3Cd,GAAMA,EAAE5I,OAASuE,EAAMvE,QAG1B+H,EAAUuB,aAAa9I,YAAY+D,EAAM1D,eACzCkH,EAAUG,gBAAkBH,EAAUG,gBAAgBwB,QACnDd,GACCA,EAAE/H,cAAc4I,cAChBlF,EAAM1D,cAAc4I,gBAI5B1B,EAAU1H,WAAWG,YAAY+D,EAAM1D,gBAGzCuH,qBAAqBuB,GACnB5B,EAAUuB,aAAeK,EACzB5B,EAAUE,YAAY2B,SAASrF,IAC7BwD,EAAUuB,aAAahJ,SAASiE,MAElCwD,EAAUE,YAAc,GAExBE,EAAgBwB,IAGlBxB,gBAAgB0B,GACd9B,EAAU1H,WAAWyJ,WAAWD,EAAShJ,gBAG3CkJ,QAAQ9M,GACN,MAAM6J,EAAOiB,EAAU1H,WAAWkI,UAC9BtL,IAAW6J,GACbiB,EAAU1H,WAAW0J,QAAQ9M,EAAQ,CACnC+M,SAASnN,EAAMgL,sBAA+B,QAKpDoC,sBAAsBhN,GACpB8K,EAAUhB,mBAAqB9J,GAEjCiN,kBAAkBjN,GAChB8K,EAAUf,eAAiB/J,GAE7BkN,WAAWlN,GACT8K,EAAUd,QAAUhK,GAEtBmN,OAAOnN,GACL,MAAMoN,EAAatC,EAAU1H,WAAW4E,YACxC8C,EAAU1H,WAAWb,QAAQ2H,IAAMlK,EACnC8K,EAAU1H,WAAWiK,UAAUD,EAAY,CACzCL,SAAS,EACT/C,QAAS,CAAC,EAAG,MAGjBqD,UAAU1D,GACRmB,EAAU1H,WAAWiK,UAAU1D,EAAQ,CACrCoD,SAAS/N,KAAK4L,sBAA+B,QAGjD0C,UAAUtN,GACR,IAAKA,EACH,OAEF,MAAMuN,EAAYxB,EAAa/L,GAC/B,IAAKuN,EAAUC,UACb,OAEF,MAAMC,EACJ3C,EAAU4C,eAAiB5C,EAAU1H,WAAW4E,YAC5C2F,GAAiBF,EAAUG,OAAOL,EAAW,GAC/CI,IACF7C,EAAU4C,cAAgBH,EAC1BzC,EAAU1H,WAAWiK,UAAUE,EAAWvO,KAAK6O,oBAInDC,UAAU9N,GACR,GAAc,MAAVA,EACF,OAEF,MAAM+N,EAAYlH,EAAO7G,GACnBgO,EACJlD,EAAUmD,eAAiBnD,EAAU1H,WAAWmI,YAEhDyC,EAAUE,MAAQH,EAAUG,KAC5BF,EAAUG,MAAQJ,EAAUI,MAE5BrD,EAAUmD,cAAgBF,EAC1BjD,EAAU1H,WAAWgL,MAAML,EAAW,CACpChB,SAAS/N,KAAK4L,sBAA+B,UAMrD5I,EAAqBqB,EAAU3D,EAAQ2D,UACvCrB,EAAqBuB,EAAa7D,EAAQ6D,aAC1CvB,EAAqBkJ,EAAiBxL,EAAQwL,iBAC9ClJ,EAAqBmJ,EAAsBzL,EAAQyL,sBAEnDL,EAAU1H,WAAayI,EAAIhB,EAAK/I,MAAOS,GAEvC9C,EAAYC,EAASoL,EAAU1H,WAAYxD,GAC3C,MAAM2I,EAAYrI,EAAYnB,EAAQyJ,OAEtCsC,EAAU1H,WAAWqF,GACnB,UACA/J,EAAS0M,EAAcC,eAAgB,MAEzCP,EAAU1H,WAAWqF,GAAG,aAAc2C,EAAcI,mBACpDV,EAAU1H,WAAWqF,GACnB,gBACA2C,EAAcQ,sBAEhBvD,EAASI,GAAGqC,EAAU1H,WAAYmF,GAClCuC,EAAUzF,OAAQ,GAClBqD,EAAAA,EAAAA,KAAS,IAAM3J,EAAQmG,KAAK,QAAS4F,EAAU1H,kBAGjDiL,EAAAA,EAAAA,KAAgB,KACVvD,EAAU1H,YACZ0H,EAAU1H,WAAW8D,YAIzB,MAAMtD,GAAgB0K,EAAAA,EAAAA,KAAS,IAAMxD,EAAU1H,aACzCiC,GAAQiJ,EAAAA,EAAAA,KAAS,IAAMxD,EAAUzF,QACvC,MAAO,CAAEwF,OAAMxF,QAAOzB,kBAExBwB,SACE,OAAOG,EAAAA,EAAAA,GACL,MACA,CAAEC,MAAO,CAAE+I,MAAO,OAAQC,OAAQ,QAAU9M,IAAK,QACjD1C,KAAKqG,MAAQrG,KAAK2J,OAAOvH,UAAY,K,kCCxZpC,MAAMxB,EAAQ,IAChBgG,EACHhD,KAAM,CACJJ,KAAMK,OACNzB,QAAS,cAEXqN,UAAW,CACTjM,KAAMW,QACNH,QAAQ,EACR5B,SAAS,GAEXyF,OAAQ,CACNrE,KAAM,CAACC,OAAQqE,OACf9D,QAAQ,EACR5B,QAAS,MAEXsN,KAAM,CACJlM,KAAM,CAACC,QACPrB,QAAS,OACT4B,QAAQ,GAEV2L,aAAc,CACZnM,KAAMyD,OACNjD,QAAQ,EACR5B,QAAS,OAIAsB,EAAQ,CAAC9C,EAAOwD,EAAYrE,KACvC,MAAQwD,QAAS4E,EAAczH,QAAS0H,GAAiBC,EACvDzH,EACAwD,EACArE,GAEIwD,EAAU,IACX4E,KACAvH,GAGCF,EAAU,IACX0H,EACHwH,aAAa9M,GACPsB,EAAWtB,MAAM+M,WACnB/M,EACIsB,EAAWtB,MAAM+M,SAASC,SAC1B1L,EAAWtB,MAAM+M,SAASE,YAGlCC,WAAWC,GACTlQ,EAAQmG,KAAK,gBAAiB+J,EAAMC,QACpCnQ,EAAQmG,KAAK,iBAAkB+J,EAAMC,SAEvCC,UAAUnP,GACR,GAAc,MAAVA,GAIAoD,EAAWtB,MAAO,CACpB,MAAMsN,EAAYhM,EAAWtB,MAAMuN,YAC9BD,GAAcA,EAAUxB,OAAO5N,IAClCoD,EAAWtB,MAAMqN,UAAUnP,MAKnC,MAAO,CAAEuC,UAAS7C,YCpDpB,MAAe,CACbqD,KAAM,U,MACNnD,EACA8C,MAAM9C,EAAOb,GACX,MAAMqE,GAAa1B,EAAAA,EAAAA,IAAI,IACjB2D,GAAQ3D,EAAAA,EAAAA,KAAI,GAEZuG,GAAmB3E,EAAAA,EAAAA,IAAOhB,GAC1Be,GAAWC,EAAAA,EAAAA,IAAO,aAExBvB,EAAAA,EAAAA,IAAQ,oBAAoB,MAAQqB,EAAWtB,MAAMwN,gBACrDvN,EAAAA,EAAAA,IACE,iBACCwN,GAAUnM,EAAWtB,MAAMwN,aAAaE,UAAYD,KAEvDxN,EAAAA,EAAAA,IACE,WACC0N,GAAYrM,EAAWtB,MAAM4N,SAAWtM,EAAWtB,MAAM4N,QAAQD,KAEpE,MAAM,QAAElN,EAAF,QAAW7C,GAAYiQ,EAAY/P,EAAOwD,EAAYrE,GA4B5D,YA3BqBsD,IAAjBE,EAAQmM,aAIHnM,EAAQmM,MAGjBvG,EAAAA,EAAAA,KAAUzH,UACR,MAAM,OAAEkP,EAAF,SAAUvH,GAAaJ,EACzB/F,EAAiBoG,QACX,8BACVlF,EAAWtB,MAAQ8N,EAAOhQ,EAAMiH,OAAQtE,GAExC,MAAMgG,EAAYrI,EAAYnB,EAAQyJ,OACtCH,EAASI,GAAGrF,EAAWtB,MAAOyG,GAE9BnF,EAAWtB,MAAM2G,GAAG,OAAQ/J,EAASgB,EAAQsP,WAAY,MACzDvP,EAAYC,EAAS0D,EAAWtB,MAAOlC,GACvCyD,EAAS,IACJzD,KACAF,EACHkE,cAAeR,EAAWtB,QAE5BuD,EAAMvD,OAAQ,GACd4G,EAAAA,EAAAA,KAAS,IAAM3J,EAAQmG,KAAK,QAAS9B,EAAWtB,YAG3C,CAAEuD,QAAOzB,cAAeR,IAEjCgC,SACE,OAAOA,EAAOpG,KAAKqG,MAAOrG,KAAK2J,S,qCC/D5B,MAAM/I,EAAQ,IAChBgH,EACHiJ,QAAS,CACPrN,KAAMsE,MACN1F,QAAS,IAAM,IAEjB0O,aAAc,CACZtN,KAAMyD,OACNjD,QAAQ,EACR5B,QAAS,GAEX2O,OAAQ,CACNvN,KAAMW,QACNH,QAAQ,EACR5B,SAAS,ICdAxB,EAAQ,IAChBoQ,GCAE,MAAMpQ,EAAQ,IAChB+C,EACHsN,QAAS,CACPzN,KAAMK,OACNzB,QAAS,OCLN,MAAMxB,EAAQ,IAChBsQ,EACHC,IAAK,CACH3N,KAAMW,QACN/B,SAAS,GAEXgP,WAAY,CACV5N,KAAMK,OACNzB,QAAS,OAEXiP,aAAc,CACZ7N,KAAMW,QACN/B,SAAS,GAEXkP,IAAK,CACH9N,KAAMK,OACNzB,QAAS,OAIAsB,EAAQ,CAAC9C,EAAOwD,KAC3B,MACEb,QAASgO,EACT7Q,QAAS8Q,GACPC,EAAe7Q,EAAOwD,GACpBb,EAAU,IACXgO,EACHJ,IAAKvQ,EAAMuQ,IACXC,WAAYxQ,EAAMwQ,WAClBC,aAAczQ,EAAMyQ,cAEtB,MAAO,CACL9N,UACA7C,QAAS,IACJ8Q,KC1BT,MAAe,C,MACb5Q,EACA8C,MAAM9C,EAAOb,GACX,MAAMqE,GAAa1B,EAAAA,EAAAA,IAAI,IAEjBuG,GAAmB3E,EAAAA,EAAAA,IAAOhB,GAC1Be,GAAWC,EAAAA,EAAAA,IAAO,aAElB,QAAEf,EAAF,QAAW7C,GAAYgR,EAAe9Q,EAAOwD,GAoBnD,OAlBA+E,EAAAA,EAAAA,KAAUzH,UACR,MAAM,UAAEiQ,EAAF,SAAatI,GAAaJ,EAC5B/F,EAAiBoG,QACX,8BACVlF,EAAWtB,MAAQ6O,EAAU/Q,EAAM0Q,IAAK/N,GAExC,MAAMgG,EAAYrI,EAAYnB,EAAQyJ,OACtCH,EAASI,GAAGrF,EAAWtB,MAAOyG,GAE9B9I,EAAYC,EAAS0D,EAAWtB,MAAOlC,GACvCyD,EAAS,IACJzD,KACAF,EACHkE,cAAeR,EAAWtB,SAE5B4G,EAAAA,EAAAA,KAAS,IAAM3J,EAAQmG,KAAK,QAAS9B,EAAWtB,YAG3C,CAAE8B,cAAeR,IAE1BgC,SACE,OAAO,M,wCCnBDjC,QAWAA,S","sources":["webpack://delish/../src/utils.js","webpack://delish/../src/functions/component.js","webpack://delish/../src/functions/layer.js","webpack://delish/../src/functions/interactiveLayer.js","webpack://delish/../src/functions/path.js","webpack://delish/../src/functions/circleMarker.js","webpack://delish/../src/functions/control.js","webpack://delish/../src/components/LControl.vue","webpack://delish/../src/functions/controlLayers.js","webpack://delish/../src/functions/controlScale.js","webpack://delish/../src/functions/layerGroup.js","webpack://delish/../src/functions/geoJSON.js","webpack://delish/../src/components/LGeoJson.vue","webpack://delish/../src/functions/gridLayer.js","webpack://delish/../src/functions/icon.js","webpack://delish/../src/functions/imageOverlay.js","webpack://delish/../src/components/LImageOverlay.vue","webpack://delish/../src/components/LMap.vue","webpack://delish/../src/functions/marker.js","webpack://delish/../src/components/LMarker.vue","webpack://delish/../src/functions/polyline.js","webpack://delish/../src/functions/polygon.js","webpack://delish/../src/functions/popper.js","webpack://delish/../src/functions/tileLayer.js","webpack://delish/../src/components/LTileLayer.vue","webpack://delish/../src/functions/wmsTileLayer.js"],"sourcesContent":["import { watch, ref, provide } from \"vue\";\n\nexport const debounce = (fn, time) => {\n  let timeout;\n\n  return function (...args) {\n    const context = this;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      fn.apply(context, args);\n      timeout = null;\n    }, time);\n  };\n};\n\nexport const capitalizeFirstLetter = (string) => {\n  if (!string || typeof string.charAt !== \"function\") {\n    return string;\n  }\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\nexport const propsBinder = (methods, leafletElement, props) => {\n  for (const key in props) {\n    const setMethodName = \"set\" + capitalizeFirstLetter(key);\n    if (methods[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal, oldVal) => {\n          methods[setMethodName](newVal, oldVal);\n        }\n      );\n    } else if (leafletElement[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal) => {\n          leafletElement[setMethodName](newVal);\n        }\n      );\n    }\n  }\n};\n\nexport const remapEvents = (contextAttrs) => {\n  const result = {};\n  for (const attrName in contextAttrs) {\n    if (\n      attrName.startsWith(\"on\") &&\n      !attrName.startsWith(\"onUpdate\") &&\n      attrName !== \"onReady\"\n    ) {\n      const eventName = attrName.slice(2).toLocaleLowerCase();\n      result[eventName] = contextAttrs[attrName];\n    }\n  }\n  return result;\n};\n\nexport const resetWebpackIcon = async (Icon) => {\n  const modules = await Promise.all([\n    import(\"leaflet/dist/images/marker-icon-2x.png\"),\n    import(\"leaflet/dist/images/marker-icon.png\"),\n    import(\"leaflet/dist/images/marker-shadow.png\"),\n  ]);\n\n  delete Icon.Default.prototype._getIconUrl;\n\n  Icon.Default.mergeOptions({\n    iconRetinaUrl: modules[0].default,\n    iconUrl: modules[1].default,\n    shadowUrl: modules[2].default,\n  });\n};\n\n/**\n * Wraps a placeholder function and provides it with the given name.\n * The wrapper can later be updated with {@link updateLeafletWrapper}\n * to provide a different function.\n *\n * @param {String} methodName Key used to provide the wrapper function\n */\nexport const provideLeafletWrapper = (methodName) => {\n  const wrapped = ref(() =>\n    console.warn(`Method ${methodName} has been invoked without being replaced`)\n  );\n  const wrapper = (...args) => wrapped.value(...args);\n  // eslint-disable-next-line vue/no-ref-as-operand\n  wrapper.wrapped = wrapped;\n  provide(methodName, wrapper);\n\n  return wrapper;\n};\n\n/**\n * Change the function that will be executed when an injected Leaflet wrapper\n * is invoked.\n *\n * @param {*} wrapper Provided wrapper whose wrapped function is to be updated\n * @param {function} leafletMethod New method to be wrapped by the wrapper\n */\nexport const updateLeafletWrapper = (wrapper, leafletMethod) =>\n  (wrapper.wrapped.value = leafletMethod);\n\nexport const WINDOW_OR_GLOBAL =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global === \"object\" && global.global === global && global) ||\n  undefined;\n\nexport const GLOBAL_LEAFLET_OPT = \"useGlobalLeaflet\";\n","export const props = {\n  options: {\n    type: Object,\n    default: () => ({}),\n  },\n};\n\nexport const setup = (props) => {\n  return { options: props.options, methods: {} };\n};\n","import { onUnmounted, provide, inject, h } from \"vue\";\nimport { props as componentProps, setup as componentSetup } from \"./component\";\n\nexport const props = {\n  ...componentProps,\n  pane: {\n    type: String,\n    default: \"overlayPane\",\n  },\n  attribution: {\n    type: String,\n    default: null,\n  },\n  name: {\n    type: String,\n    custom: true,\n    default: undefined,\n  },\n  layerType: {\n    type: String,\n    custom: true,\n    default: undefined,\n  },\n  visible: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n};\n\nexport const setup = (props, leafletRef, context) => {\n  const addLayer = inject(\"addLayer\");\n  const removeLayer = inject(\"removeLayer\");\n  const {\n    options: componentOptions,\n    methods: componentMethods,\n  } = componentSetup(props);\n\n  const options = {\n    ...componentOptions,\n    attribution: props.attribution,\n    pane: props.pane,\n  };\n\n  const addThisLayer = () => addLayer({ leafletObject: leafletRef.value });\n  const removeThisLayer = () =>\n    removeLayer({ leafletObject: leafletRef.value });\n\n  const methods = {\n    ...componentMethods,\n    setAttribution(val, old) {\n      const attributionControl = this.$parent.leafletObject.attributionControl;\n      attributionControl.removeAttribution(old).addAttribution(val);\n    },\n    setName() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setLayerType() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setVisible(isVisible) {\n      if (leafletRef.value) {\n        if (isVisible) {\n          addThisLayer();\n        } else {\n          removeThisLayer();\n        }\n      }\n    },\n    bindPopup({ leafletObject }) {\n      leafletRef.value.bindPopup(leafletObject);\n    },\n    bindTooltip({ leafletObject }) {\n      leafletRef.value.bindTooltip(leafletObject);\n    },\n    unbindTooltip() {\n      const tooltip = leafletRef.value ? leafletRef.value.getTooltip() : null;\n      if (tooltip) {\n        tooltip.unbindTooltip();\n      }\n    },\n    unbindPopup() {\n      const popup = leafletRef.value ? leafletRef.value.getPopup() : null;\n      if (popup) {\n        popup.unbindPopup();\n      }\n    },\n    updateVisibleProp(value) {\n      /**\n       * Triggers when the visible prop needs to be updated\n       * @type {boolean}\n       * @property {boolean} value - value of the visible property\n       */\n      context.emit(\"update:visible\", value);\n    },\n  };\n\n  provide(\"bindPopup\", methods.bindPopup);\n  provide(\"bindTooltip\", methods.bindTooltip);\n  provide(\"unbindTooltip\", methods.unbindTooltip);\n  provide(\"unbindPopup\", methods.unbindPopup);\n\n  onUnmounted(() => {\n    methods.unbindPopup();\n    methods.unbindTooltip();\n    removeThisLayer();\n  });\n\n  return { options, methods };\n};\n\nexport const render = (ready, slots) => {\n  if (ready && slots.default) {\n    return h(\"div\", { style: { display: \"none\" } }, slots.default());\n  }\n};\n","import { props as componentProps, setup as componentSetup } from \"./component\";\n\nexport const props = {\n  ...componentProps,\n  interactive: {\n    type: Boolean,\n    default: true,\n  },\n  bubblingMouseEvents: {\n    type: Boolean,\n    default: true,\n  },\n};\n\nexport const setup = (props) => {\n  const { options: componentOptions, methods } = componentSetup(props);\n  const options = {\n    ...componentOptions,\n    interactive: props.interactive,\n    bubblingMouseEvents: props.bubblingMouseEvents,\n  };\n\n  return { options, methods };\n};\n","import { onBeforeUnmount, inject } from \"vue\";\nimport { props as layerProps, setup as layerSetup } from \"./layer\";\nimport {\n  props as interactiveLayerProps,\n  setup as interactiveLayerSetup,\n} from \"./interactiveLayer\";\n\nexport const props = {\n  ...layerProps,\n  ...interactiveLayerProps,\n  stroke: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  color: {\n    type: String,\n    custom: true,\n    default: \"#3388ff\",\n  },\n  weight: {\n    type: Number,\n    custom: true,\n    default: 3,\n  },\n  opacity: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  lineCap: {\n    type: String,\n    custom: true,\n    default: \"round\",\n  },\n  lineJoin: {\n    type: String,\n    custom: true,\n    default: \"round\",\n  },\n  dashArray: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  dashOffset: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  fill: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n  fillColor: {\n    type: String,\n    custom: true,\n    default: \"#3388ff\",\n  },\n  fillOpacity: {\n    type: Number,\n    custom: true,\n    default: 0.2,\n  },\n  fillRule: {\n    type: String,\n    custom: true,\n    default: \"evenodd\",\n  },\n  className: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n};\n\nexport const setup = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = layerSetup(\n    props,\n    leafletRef,\n    context\n  );\n  const {\n    options: interactiveLayerOptions,\n    methods: interactiveLayerMethods,\n  } = interactiveLayerSetup(props, leafletRef, context);\n\n  const removeLayer = inject(\"removeLayer\");\n\n  const options = {\n    ...layerOptions,\n    ...interactiveLayerOptions,\n    stroke: props.stroke,\n    color: props.color,\n    weight: props.weight,\n    opacity: props.opacity,\n    lineCap: props.lineCap,\n    lineJoin: props.lineJoin,\n    dashArray: props.dashArray,\n    dashOffset: props.dashOffset,\n    fill: props.fill,\n    fillColor: props.fillColor,\n    fillOpacity: props.fillOpacity,\n    fillRule: props.fillRule,\n    className: props.className,\n  };\n  const methods = {\n    ...layerMethods,\n    ...interactiveLayerMethods,\n    setStroke(stroke) {\n      leafletRef.value.setStyle({ stroke });\n    },\n    setColor(color) {\n      leafletRef.value.setStyle({ color });\n    },\n    setWeight(weight) {\n      leafletRef.value.setStyle({ weight });\n    },\n    setOpacity(opacity) {\n      leafletRef.value.setStyle({ opacity });\n    },\n    setLineCap(lineCap) {\n      leafletRef.value.setStyle({ lineCap });\n    },\n    setLineJoin(lineJoin) {\n      leafletRef.value.setStyle({ lineJoin });\n    },\n    setDashArray(dashArray) {\n      leafletRef.value.setStyle({ dashArray });\n    },\n    setDashOffset(dashOffset) {\n      leafletRef.value.setStyle({ dashOffset });\n    },\n    setFill(fill) {\n      leafletRef.value.setStyle({ fill });\n    },\n    setFillColor(fillColor) {\n      leafletRef.value.setStyle({ fillColor });\n    },\n    setFillOpacity(fillOpacity) {\n      leafletRef.value.setStyle({ fillOpacity });\n    },\n    setFillRule(fillRule) {\n      leafletRef.value.setStyle({ fillRule });\n    },\n    setClassName(className) {\n      leafletRef.value.setStyle({ className });\n    },\n  };\n\n  onBeforeUnmount(() => {\n    removeLayer({ leafletObject: leafletRef.value });\n  });\n\n  return { options, methods };\n};\n","import { props as pathProps, setup as pathSetup } from \"./path\";\n\nexport const props = {\n  ...pathProps,\n  latLng: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  /**\n   * Radius of the marker in pixels.\n   */\n  radius: {\n    type: Number,\n    default: null,\n  },\n};\n\nexport const setup = (props, leafletRef, context) => {\n  const { options: pathOptions, methods: pathMethods } = pathSetup(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...pathOptions,\n    ...props,\n  };\n  const methods = {\n    ...pathMethods,\n    setRadius(radius) {\n      leafletRef.value.setRadius(radius);\n    },\n    setLatLng(latLng) {\n      leafletRef.value.setLatLng(latLng);\n    },\n  };\n\n  return { options, methods };\n};\n","import { onUnmounted, h } from \"vue\";\nimport { props as componentProps, setup as componentSetup } from \"./component\";\n\nexport const props = {\n  ...componentProps,\n  position: {\n    type: String,\n    default: \"topright\",\n  },\n};\n\nexport const setup = (props, leafletRef) => {\n  const {\n    options: componentOptions,\n    methods: componentMethods,\n  } = componentSetup(props);\n  const options = {\n    ...componentOptions,\n    position: props.position,\n  };\n\n  const methods = {\n    ...componentMethods,\n    setPosition(position) {\n      if (leafletRef.value) {\n        leafletRef.value.setPosition(position);\n      }\n    },\n  };\n\n  onUnmounted(() => {\n    if (leafletRef.value) {\n      leafletRef.value.remove();\n    }\n  });\n\n  return { options, methods };\n};\n\nexport const render = (slots) => {\n  if (slots.default) {\n    return h(\"div\", { ref: \"root\" }, slots.default());\n  }\n  return null;\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  props as controlProps,\n  setup as controlSetup,\n  render,\n} from \"../functions/control\";\nimport { propsBinder, WINDOW_OR_GLOBAL, GLOBAL_LEAFLET_OPT } from \"../utils.js\";\n\nexport default {\n  name: \"LControl\",\n  props: {\n    ...controlProps,\n    disableClickPropagation: {\n      type: Boolean,\n      custom: true,\n      default: true,\n    },\n    disableScrollPropagation: {\n      type: Boolean,\n      custom: true,\n      default: false,\n    },\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = controlSetup(props, leafletRef);\n\n    onMounted(async () => {\n      const { Control, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      const LControl = Control.extend({\n        onAdd() {\n          return root.value;\n        },\n      });\n\n      leafletRef.value = new LControl(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n\n      if (props.disableClickPropagation) {\n        DomEvent.disableClickPropagation(root.value);\n      }\n      if (props.disableScrollPropagation) {\n        DomEvent.disableScrollPropagation(root.value);\n      }\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.$slots);\n  },\n};\n</script>\n","import { props as controlProps, setup as controlSetup } from \"./control\";\n\nexport const props = {\n  ...controlProps,\n  collapsed: {\n    type: Boolean,\n    default: true,\n  },\n  autoZIndex: {\n    type: Boolean,\n    default: true,\n  },\n  hideSingleBase: {\n    type: Boolean,\n    default: false,\n  },\n  sortLayers: {\n    type: Boolean,\n    default: false,\n  },\n  sortFunction: {\n    type: Function,\n    default: undefined,\n  },\n};\n\nexport const setup = (props, leafletRef) => {\n  const { options: controlOptions } = controlSetup(props, leafletRef);\n  const options = {\n    ...controlOptions,\n    collapsed: props.collapsed,\n    autoZIndex: props.autoZIndex,\n    hideSingleBase: props.hideSingleBase,\n    sortLayers: props.sortLayers,\n    sortFunction: props.sortFunction,\n  };\n\n  const methods = {\n    addLayer(layer) {\n      if (layer.layerType === \"base\") {\n        leafletRef.value.addBaseLayer(layer.leafletObject, layer.name);\n      } else if (layer.layerType === \"overlay\") {\n        leafletRef.value.addOverlay(layer.leafletObject, layer.name);\n      }\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    },\n  };\n  return { options, methods };\n};\n","import { props as controlProps, setup as controlSetup } from \"./control\";\n\nexport const props = {\n  ...controlProps,\n  maxWidth: {\n    type: Number,\n    default: 100,\n  },\n  metric: {\n    type: Boolean,\n    default: true,\n  },\n  imperial: {\n    type: Boolean,\n    default: true,\n  },\n  updateWhenIdle: {\n    type: Boolean,\n    default: false,\n  },\n};\n\nexport const setup = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = controlSetup(\n    props,\n    leafletRef\n  );\n  const options = {\n    ...controlOptions,\n    maxWidth: props.maxWidth,\n    metric: props.metric,\n    imperial: props.imperial,\n    updateWhenIdle: props.updateWhenIdle,\n  };\n\n  return { options, methods: controlMethods };\n};\n","import { provide } from \"vue\";\nimport { props as layerProps, setup as layerSetup } from \"./layer\";\n\nexport const props = {\n  ...layerProps,\n};\n\nexport const setup = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = layerSetup(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = {\n    ...layerOptions,\n  };\n\n  const methods = {\n    ...layerMethods,\n    addLayer(layer) {\n      leafletRef.value.addLayer(layer.leafletObject);\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    },\n  };\n\n  provide(\"addLayer\", methods.addLayer);\n  provide(\"removeLayer\", methods.removeLayer);\n\n  return { options, methods };\n};\n","import {\n  props as layerGroupProps,\n  setup as layerGroupSetup,\n} from \"./layerGroup\";\n\nexport const props = {\n  ...layerGroupProps,\n  geojson: {\n    type: [Object, Array],\n    default: () => ({}),\n  },\n};\n\nexport const setup = (props, leafletRef) => {\n  const { options: layerOptions, methods: layerGroupMethods } = layerGroupSetup(\n    props,\n    leafletRef\n  );\n\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerGroupMethods,\n    setGeojson(newVal) {\n      leafletRef.value.clearLayers();\n      leafletRef.value.addData(newVal);\n    },\n    getGeoJSONData() {\n      return leafletRef.value.toGeoJSON();\n    },\n    getBounds() {\n      return leafletRef.value.getBounds();\n    },\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { props, setup as geoJSONSetup } from \"../functions/geoJSON\";\nimport { render } from \"../functions/layer\";\n\nexport default {\n  props,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods, options } = geoJSONSetup(props, leafletRef);\n\n    onMounted(async () => {\n      const { geoJSON, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      leafletRef.value = geoJSON(props.geojson, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","import { props as layerProps, setup as layerSetup } from \"./layer\";\n\nexport const props = {\n  ...layerProps,\n  pane: {\n    type: String,\n    default: \"tilePane\",\n  },\n  opacity: {\n    type: Number,\n    custom: false,\n    default: 1.0,\n  },\n  zIndex: {\n    type: Number,\n    default: 1,\n  },\n  tileSize: {\n    type: Number,\n    default: 256,\n  },\n  noWrap: {\n    type: Boolean,\n    default: false,\n  },\n  minZoom: {\n    type: Number,\n    default: 0,\n  },\n  maxZoom: {\n    type: Number,\n    default: undefined,\n  },\n};\n\nexport const setup = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = layerSetup(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    pane: props.pane,\n    opacity: props.opacity,\n    zIndex: props.zIndex,\n    tileSize: props.tileSize,\n    noWrap: props.noWrap,\n    minZoom: props.minZoom,\n    maxZoom: props.maxZoom,\n  };\n  return { options, methods: { ...layerMethods } };\n};\n","export const props = {\n  iconUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  iconRetinaUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  iconSize: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  iconAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  popupAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  tooltipAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  shadowUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  shadowRetinaUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  shadowSize: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  shadowAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  bgPos: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  className: {\n    type: String,\n    custom: true,\n    default: \"\",\n  },\n  options: {\n    type: Object,\n    custom: true,\n    default: () => ({}),\n  },\n};\n","import { props as layerProps, setup as layerSetup } from \"./layer\";\n/**\n * @typedef {import('leaflet/dist/leaflet-src.esm.js').LatLngBounds} LatLngBounds\n */\n\nexport const props = {\n  ...layerProps,\n  url: {\n    type: String,\n    required: true,\n  },\n  bounds: {\n    type: [Array, Object],\n    required: true,\n  },\n  opacity: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  alt: {\n    type: String,\n    default: \"\",\n  },\n  interactive: {\n    type: Boolean,\n    default: false,\n  },\n  crossOrigin: {\n    type: Boolean,\n    default: false,\n  },\n  errorOverlayUrl: {\n    type: String,\n    custom: true,\n    default: \"\",\n  },\n  zIndex: {\n    type: Number,\n    custom: true,\n    default: 1,\n  },\n  className: {\n    type: String,\n    default: \"\",\n  },\n};\n\nexport const setup = (setupProps, LeafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = layerSetup(\n    setupProps,\n    LeafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    ...setupProps,\n  };\n\n  const methods = {\n    ...layerMethods,\n    /**\n     * Sets the opacity of the overlay.\n     * @param {number} opacity\n     */\n    setOpacity(opacity) {\n      return LeafletRef.value.setOpacity(opacity);\n    },\n    /**\n     * Changes the URL of the image.\n     * @param {string} url\n     */\n    setUrl(url) {\n      return LeafletRef.value.setUrl(url);\n    },\n    /**\n     * Update the bounds that this ImageOverlay covers\n     * @param {LatLngBounds | Array<Array<number>>} bounds\n     */\n    setBounds(bounds) {\n      return LeafletRef.value.setBounds(bounds);\n    },\n    /**\n     * Get the bounds that this ImageOverlay covers\n     * @returns {LatLngBounds}\n     */\n    getBounds() {\n      return LeafletRef.value.getBounds();\n    },\n    /**\n     * Returns the instance of HTMLImageElement used by this overlay.\n     * @returns {HTMLElement}\n     */\n    getElement() {\n      return LeafletRef.value.getElement();\n    },\n    /**\n     * Brings the layer to the top of all overlays.\n     */\n    bringToFront() {\n      return LeafletRef.value.bringToFront();\n    },\n    /**\n     * Brings the layer to the bottom of all overlays.\n     */\n    bringToBack() {\n      return LeafletRef.value.bringToBack();\n    },\n    /**\n     * Changes the zIndex of the image overlay.\n     * @param {number} zIndex\n     */\n    setZIndex(zIndex) {\n      return LeafletRef.value.setZIndex(zIndex);\n    },\n  };\n\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport {\n  props as imageOverlayProps,\n  setup as imageOverlaySetup,\n} from \"../functions/imageOverlay\";\nimport { render } from \"../functions/layer\";\n\n/**\n * ImageOverlay component, render a plain image instead of a geospatial map.\n */\nexport default {\n  name: \"LImageOverlay\",\n  props: imageOverlayProps,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = imageOverlaySetup(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { imageOverlay, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n      leafletRef.value = imageOverlay(props.url, props.bounds, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","<script>\nimport {\n  computed,\n  h,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n} from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  debounce,\n  resetWebpackIcon,\n  provideLeafletWrapper,\n  updateLeafletWrapper,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport {\n  props as componentProps,\n  setup as componentSetup,\n} from \"../functions/component\";\n\nexport default {\n  emits: [\"ready\", \"update:zoom\", \"update:center\", \"update:bounds\"],\n  props: {\n    ...componentProps,\n    /**\n     * The center of the map, supports .sync modifier\n     */\n    center: {\n      type: [Object, Array],\n      default: () => [0, 0],\n    },\n    /**\n     * The bounds of the map, supports .sync modifier\n     */\n    bounds: {\n      type: [Array, Object],\n      default: undefined,\n    },\n    /**\n     * The max bounds of the map\n     */\n    maxBounds: {\n      type: [Array, Object],\n      default: undefined,\n    },\n    /**\n     * The zoom of the map, supports .sync modifier\n     */\n    zoom: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * The minZoom of the map\n     */\n    minZoom: {\n      type: Number,\n      default: undefined,\n    },\n    /**\n     * The maxZoom of the map\n     */\n    maxZoom: {\n      type: Number,\n      default: undefined,\n    },\n    /**\n     * The paddingBottomRight of the map\n     */\n    paddingBottomRight: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The paddingTopLeft of the map\n     */\n    paddingTopLeft: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The padding of the map\n     */\n    padding: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The worldCopyJump option for the map\n     */\n    worldCopyJump: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The CRS to use for the map. Can be an object that defines a coordinate reference\n     * system for projecting geographical points into screen coordinates and back\n     * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string\n     * name identifying one of Leaflet's defined CRSs, such as \"EPSG4326\".\n     */\n    crs: {\n      type: [String, Object],\n      default: \"EPSG3857\",\n    },\n    maxBoundsViscosity: {\n      type: Number,\n      default: undefined,\n    },\n    inertia: {\n      type: Boolean,\n      default: undefined,\n    },\n    inertiaDeceleration: {\n      type: Number,\n      default: undefined,\n    },\n    inertiaMaxSpeed: {\n      type: Number,\n      default: undefined,\n    },\n    easeLinearity: {\n      type: Number,\n      default: undefined,\n    },\n    zoomAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    zoomAnimationThreshold: {\n      type: Number,\n      default: undefined,\n    },\n    fadeAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    markerZoomAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    noBlockingAnimations: {\n      type: Boolean,\n      default: false,\n    },\n    useGlobalLeaflet: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props, context) {\n    const root = ref(null);\n    const blueprint = reactive({\n      ready: false,\n      leafletRef: {},\n      layersToAdd: [],\n      layersInControl: [],\n    });\n    const { options: componentOptions } = componentSetup(props);\n    const options = {\n      ...componentOptions,\n      minZoom: props.minZoom,\n      maxZoom: props.maxZoom,\n      maxBounds: props.maxBounds,\n      maxBoundsViscosity: props.maxBoundsViscosity,\n      worldCopyJump: props.worldCopyJump,\n      crs: props.crs,\n      center: props.center,\n      zoom: props.zoom,\n      inertia: props.inertia,\n      inertiaDeceleration: props.inertiaDeceleration,\n      inertiaMaxSpeed: props.inertiaMaxSpeed,\n      easeLinearity: props.easeLinearity,\n      zoomAnimation: props.zoomAnimation,\n      zoomAnimationThreshold: props.zoomAnimationThreshold,\n      fadeAnimation: props.fadeAnimation,\n      markerZoomAnimation: props.markerZoomAnimation,\n    };\n\n    const addLayer = provideLeafletWrapper(\"addLayer\");\n    const removeLayer = provideLeafletWrapper(\"removeLayer\");\n    const registerControl = provideLeafletWrapper(\"registerControl\");\n    const registerLayerControl = provideLeafletWrapper(\"registerLayerControl\");\n    provide(GLOBAL_LEAFLET_OPT, props.useGlobalLeaflet);\n\n    const eventHandlers = {\n      moveEndHandler() {\n        /**\n         * Triggers when zoom is updated\n         * @type {number,string}\n         */\n        context.emit(\"update:zoom\", blueprint.leafletRef.getZoom());\n        /**\n         * Triggers when center is updated\n         * @type {object,array}\n         */\n        context.emit(\"update:center\", blueprint.leafletRef.getCenter());\n\n        /**\n         * Triggers when bounds are updated\n         * @type {object}\n         */\n        context.emit(\"update:bounds\", blueprint.leafletRef.getBounds());\n      },\n      overlayAddHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(true);\n        }\n      },\n      overlayRemoveHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(false);\n        }\n      },\n    };\n\n    onMounted(async () => {\n      if (props.useGlobalLeaflet) {\n        WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || (await import(\"leaflet\"));\n      }\n      const {\n        map,\n        CRS,\n        Icon,\n        latLngBounds,\n        latLng,\n        DomEvent,\n      } = props.useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n\n      try {\n        options.beforeMapMount && (await options.beforeMapMount());\n      } catch (error) {\n        console.error(\n          `The following error occurred running the provided beforeMapMount hook ${error.message}`\n        );\n      }\n\n      await resetWebpackIcon(Icon);\n\n      const optionsCrs =\n        typeof options.crs == \"string\" ? CRS[options.crs] : options.crs;\n      options.crs = optionsCrs || CRS.EPSG3857;\n\n      const methods = {\n        addLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd.push(layer);\n            } else {\n              const exist = blueprint.layersInControl.find(\n                (l) =>\n                  l.leafletObject._leaflet_id ===\n                  layer.leafletObject._leaflet_id\n              );\n              if (!exist) {\n                blueprint.layerControl.addLayer(layer);\n                blueprint.layersInControl.push(layer);\n              }\n            }\n          }\n          if (layer.visible !== false) {\n            blueprint.leafletRef.addLayer(layer.leafletObject);\n          }\n        },\n        removeLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd = blueprint.layersToAdd.filter(\n                (l) => l.name !== layer.name\n              );\n            } else {\n              blueprint.layerControl.removeLayer(layer.leafletObject);\n              blueprint.layersInControl = blueprint.layersInControl.filter(\n                (l) =>\n                  l.leafletObject._leaflet_id !==\n                  layer.leafletObject._leaflet_id\n              );\n            }\n          }\n          blueprint.leafletRef.removeLayer(layer.leafletObject);\n        },\n\n        registerLayerControl(lControlLayer) {\n          blueprint.layerControl = lControlLayer;\n          blueprint.layersToAdd.forEach((layer) => {\n            blueprint.layerControl.addLayer(layer);\n          });\n          blueprint.layersToAdd = [];\n\n          registerControl(lControlLayer);\n        },\n\n        registerControl(lControl) {\n          blueprint.leafletRef.addControl(lControl.leafletObject);\n        },\n\n        setZoom(newVal) {\n          const zoom = blueprint.leafletRef.getZoom();\n          if (newVal !== zoom) {\n            blueprint.leafletRef.setZoom(newVal, {\n              animate: props.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n\n        setPaddingBottomRight(newVal) {\n          blueprint.paddingBottomRight = newVal;\n        },\n        setPaddingTopLeft(newVal) {\n          blueprint.paddingTopLeft = newVal;\n        },\n        setPadding(newVal) {\n          blueprint.padding = newVal;\n        },\n        setCrs(newVal) {\n          const prevBounds = blueprint.leafletRef.getBounds();\n          blueprint.leafletRef.options.crs = newVal;\n          blueprint.leafletRef.fitBounds(prevBounds, {\n            animate: false,\n            padding: [0, 0],\n          });\n        },\n        fitBounds(bounds) {\n          blueprint.leafletRef.fitBounds(bounds, {\n            animate: this.noBlockingAnimations ? false : null,\n          });\n        },\n        setBounds(newVal) {\n          if (!newVal) {\n            return;\n          }\n          const newBounds = latLngBounds(newVal);\n          if (!newBounds.isValid()) {\n            return;\n          }\n          const oldBounds =\n            blueprint.lastSetBounds || blueprint.leafletRef.getBounds();\n          const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals\n          if (boundsChanged) {\n            blueprint.lastSetBounds = newBounds;\n            blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);\n          }\n        },\n\n        setCenter(newVal) {\n          if (newVal == null) {\n            return;\n          }\n          const newCenter = latLng(newVal);\n          const oldCenter =\n            blueprint.lastSetCenter || blueprint.leafletRef.getCenter();\n          if (\n            oldCenter.lat !== newCenter.lat ||\n            oldCenter.lng !== newCenter.lng\n          ) {\n            blueprint.lastSetCenter = newCenter;\n            blueprint.leafletRef.panTo(newCenter, {\n              animate: this.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n      };\n\n      updateLeafletWrapper(addLayer, methods.addLayer);\n      updateLeafletWrapper(removeLayer, methods.removeLayer);\n      updateLeafletWrapper(registerControl, methods.registerControl);\n      updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);\n\n      blueprint.leafletRef = map(root.value, options);\n\n      propsBinder(methods, blueprint.leafletRef, props);\n      const listeners = remapEvents(context.attrs);\n\n      blueprint.leafletRef.on(\n        \"moveend\",\n        debounce(eventHandlers.moveEndHandler, 100)\n      );\n      blueprint.leafletRef.on(\"overlayadd\", eventHandlers.overlayAddHandler);\n      blueprint.leafletRef.on(\n        \"overlayremove\",\n        eventHandlers.overlayRemoveHandler\n      );\n      DomEvent.on(blueprint.leafletRef, listeners);\n      blueprint.ready = true;\n      nextTick(() => context.emit(\"ready\", blueprint.leafletRef));\n    });\n\n    onBeforeUnmount(() => {\n      if (blueprint.leafletRef) {\n        blueprint.leafletRef.remove();\n      }\n    });\n\n    const leafletObject = computed(() => blueprint.leafletRef);\n    const ready = computed(() => blueprint.ready);\n    return { root, ready, leafletObject };\n  },\n  render() {\n    return h(\n      \"div\",\n      { style: { width: \"100%\", height: \"100%\" }, ref: \"root\" },\n      this.ready ? this.$slots.default() : {}\n    );\n  },\n};\n</script>\n","import { props as layerProps, setup as layerSetup } from \"./layer\";\n\nexport const props = {\n  ...layerProps,\n  pane: {\n    type: String,\n    default: \"markerPane\",\n  },\n  draggable: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n  latLng: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  icon: {\n    type: [Object],\n    default: () => undefined,\n    custom: false,\n  },\n  zIndexOffset: {\n    type: Number,\n    custom: false,\n    default: null,\n  },\n};\n\nexport const setup = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = layerSetup(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerMethods,\n    setDraggable(value) {\n      if (leafletRef.value.dragging) {\n        value\n          ? leafletRef.value.dragging.enable()\n          : leafletRef.value.dragging.disable();\n      }\n    },\n    latLngSync(event) {\n      context.emit(\"update:latLng\", event.latlng);\n      context.emit(\"update:lat-lng\", event.latlng);\n    },\n    setLatLng(newVal) {\n      if (newVal == null) {\n        return;\n      }\n\n      if (leafletRef.value) {\n        const oldLatLng = leafletRef.value.getLatLng();\n        if (!oldLatLng || !oldLatLng.equals(newVal)) {\n          leafletRef.value.setLatLng(newVal);\n        }\n      }\n    },\n  };\n  return { options, methods };\n};\n","<script>\nimport { onMounted, ref, provide, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  debounce,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { props, setup as markerSetup } from \"../functions/marker\";\nimport { render } from \"../functions/layer\";\n\n/**\n * Marker component, lets you add and personalize markers on the map\n */\nexport default {\n  name: \"LMarker\",\n  props,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    provide(\"canSetParentHtml\", () => !!leafletRef.value.getElement());\n    provide(\n      \"setParentHtml\",\n      (html) => (leafletRef.value.getElement().innerHTML = html)\n    );\n    provide(\n      \"setIcon\",\n      (newIcon) => leafletRef.value.setIcon && leafletRef.value.setIcon(newIcon)\n    );\n    const { options, methods } = markerSetup(props, leafletRef, context);\n    if (options.icon === undefined) {\n      // If the options objection has a property named 'icon', then Leaflet will overwrite\n      // the default icon with it for the marker, _even if it is undefined_.\n      // This leads to the issue discussed in https://github.com/vue-leaflet/vue-leaflet/issues/130\n      delete options.icon;\n    }\n\n    onMounted(async () => {\n      const { marker, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n      leafletRef.value = marker(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      leafletRef.value.on(\"move\", debounce(methods.latLngSync, 100));\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n</script>\n","import { props as pathProps, setup as pathSetup } from \"./path\";\n\nexport const props = {\n  ...pathProps,\n  latLngs: {\n    type: Array,\n    default: () => [],\n  },\n  smoothFactor: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  noClip: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n};\n\nexport const setup = (props, leafletRef, context) => {\n  const { options: pathOptions, methods: pathMethods } = pathSetup(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...pathOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...pathMethods,\n    setSmoothFactor(smoothFactor) {\n      leafletRef.value.setStyle({ smoothFactor });\n    },\n    setNoClip(noClip) {\n      leafletRef.value.setStyle({ noClip });\n    },\n    addLatLng(latLng) {\n      leafletRef.value.addLatLng(latLng);\n    },\n  };\n  return { options, methods };\n};\n","import { props as polylineProps, setup as polylineSetup } from \"./polyline\";\n\nexport const props = {\n  ...polylineProps,\n};\n\nexport const setup = (props, leafletRef, context) => {\n  const { options: polylineOptions, methods: polylineMethods } = polylineSetup(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...polylineOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...polylineMethods,\n    toGeoJSON(precision) {\n      return leafletRef.value.toGeoJSON(precision);\n    },\n  };\n\n  return { options, methods };\n};\n","import { h } from \"vue\";\nimport { props as componentProps, setup as componentSetup } from \"./component\";\n\nexport const props = {\n  ...componentProps,\n  content: {\n    type: String,\n    default: null,\n  },\n};\n\nexport const setup = (props, leafletRef) => {\n  const { options, methods: componentMethods } = componentSetup(props);\n  const methods = {\n    ...componentMethods,\n    setContent(newVal) {\n      if (leafletRef.value && newVal !== null && newVal !== undefined) {\n        leafletRef.value.setContent(newVal);\n      }\n    },\n  };\n  return { options, methods };\n};\n\nexport const render = (slots) => {\n  if (slots.default) {\n    return h(\"div\", { ref: \"root\" }, slots.default());\n  }\n  return null;\n};\n","import { props as gridLayerProps, setup as gridLayerSetup } from \"./gridLayer\";\n\nexport const props = {\n  ...gridLayerProps,\n  tms: {\n    type: Boolean,\n    default: false,\n  },\n  subdomains: {\n    type: String,\n    default: \"abc\",\n  },\n  detectRetina: {\n    type: Boolean,\n    default: false,\n  },\n  url: {\n    type: String,\n    default: null,\n  },\n};\n\nexport const setup = (props, leafletRef) => {\n  const {\n    options: gridLayerOptions,\n    methods: gridLayerMethods,\n  } = gridLayerSetup(props, leafletRef);\n  const options = {\n    ...gridLayerOptions,\n    tms: props.tms,\n    subdomains: props.subdomains,\n    detectRetina: props.detectRetina,\n  };\n  return {\n    options,\n    methods: {\n      ...gridLayerMethods,\n    },\n  };\n};\n","<script>\nimport { onMounted, ref, inject, nextTick } from \"vue\";\nimport {\n  remapEvents,\n  propsBinder,\n  WINDOW_OR_GLOBAL,\n  GLOBAL_LEAFLET_OPT,\n} from \"../utils.js\";\nimport { props, setup as tileLayerSetup } from \"../functions/tileLayer\";\n\nexport default {\n  props,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = tileLayerSetup(props, leafletRef);\n\n    onMounted(async () => {\n      const { tileLayer, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import(\"leaflet/dist/leaflet-src.esm\");\n      leafletRef.value = tileLayer(props.url, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { leafletObject: leafletRef };\n  },\n  render() {\n    return null;\n  },\n};\n</script>\n","import { props as tileLayerProps, setup as tileLayerSetup } from \"./tileLayer\";\n\nexport const props = {\n  ...tileLayerProps,\n  baseUrl: {\n    type: String,\n    default: null,\n    required: true,\n  },\n  layers: {\n    type: String,\n    default: \"\",\n  },\n  styles: {\n    type: String,\n    default: \"\",\n  },\n  format: {\n    type: String,\n    default: \"image/jpeg\",\n  },\n  transparent: {\n    type: Boolean,\n    custom: false,\n  },\n  version: {\n    type: String,\n    default: \"1.1.1\",\n  },\n  crs: {\n    default: null,\n  },\n  upperCase: {\n    type: Boolean,\n    default: false,\n  },\n};\n\nexport const setup = (props, leafletRef) => {\n  const {\n    options: tileLayerOptions,\n    methods: tileLayerMethods,\n  } = tileLayerSetup(props, leafletRef);\n  const options = {\n    ...tileLayerOptions,\n    layers: props.layers,\n    styles: props.styles,\n    format: props.format,\n    transparent: props.transparent,\n    version: props.version,\n    crs: props.crs,\n    upperCase: props.upperCase,\n  };\n  return {\n    options,\n    methods: {\n      ...tileLayerMethods,\n    },\n  };\n};\n"],"names":["debounce","fn","time","timeout","args","context","this","clearTimeout","setTimeout","apply","capitalizeFirstLetter","string","charAt","toUpperCase","slice","propsBinder","methods","leafletElement","props","key","setMethodName","watch","newVal","oldVal","remapEvents","contextAttrs","result","attrName","startsWith","eventName","toLocaleLowerCase","resetWebpackIcon","async","modules","Promise","all","Icon","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","default","iconUrl","shadowUrl","provideLeafletWrapper","methodName","wrapped","ref","console","warn","wrapper","value","provide","updateLeafletWrapper","leafletMethod","WINDOW_OR_GLOBAL","self","global","undefined","GLOBAL_LEAFLET_OPT","options","type","Object","setup","componentProps","pane","String","attribution","name","custom","layerType","visible","Boolean","leafletRef","addLayer","inject","removeLayer","componentOptions","componentMethods","componentSetup","addThisLayer","leafletObject","removeThisLayer","setAttribution","val","old","attributionControl","$parent","removeAttribution","addAttribution","setName","setLayerType","setVisible","isVisible","bindPopup","bindTooltip","unbindTooltip","tooltip","getTooltip","unbindPopup","popup","getPopup","updateVisibleProp","emit","onUnmounted","render","ready","slots","h","style","display","interactive","bubblingMouseEvents","layerProps","interactiveLayerProps","stroke","color","weight","Number","opacity","lineCap","lineJoin","dashArray","dashOffset","fill","fillColor","fillOpacity","fillRule","className","pathProps","latLng","Array","radius","position","setPosition","remove","layerOptions","layerMethods","layerSetup","layer","layerGroupProps","geojson","layerGroupMethods","layerGroupSetup","setGeojson","clearLayers","addData","getGeoJSONData","toGeoJSON","getBounds","useGlobalLeaflet","geoJSONSetup","onMounted","geoJSON","DomEvent","L","listeners","attrs","on","nextTick","$slots","zIndex","tileSize","noWrap","minZoom","maxZoom","iconSize","iconAnchor","popupAnchor","tooltipAnchor","shadowRetinaUrl","shadowSize","shadowAnchor","bgPos","emits","center","bounds","maxBounds","zoom","paddingBottomRight","paddingTopLeft","padding","worldCopyJump","crs","maxBoundsViscosity","inertia","inertiaDeceleration","inertiaMaxSpeed","easeLinearity","zoomAnimation","zoomAnimationThreshold","fadeAnimation","markerZoomAnimation","noBlockingAnimations","root","blueprint","reactive","layersToAdd","layersInControl","registerControl","registerLayerControl","eventHandlers","moveEndHandler","getZoom","getCenter","overlayAddHandler","e","find","l","overlayRemoveHandler","map","CRS","latLngBounds","beforeMapMount","error","message","optionsCrs","EPSG3857","layerControl","push","exist","_leaflet_id","filter","lControlLayer","forEach","lControl","addControl","setZoom","animate","setPaddingBottomRight","setPaddingTopLeft","setPadding","setCrs","prevBounds","fitBounds","setBounds","newBounds","isValid","oldBounds","lastSetBounds","boundsChanged","equals","fitBoundsOptions","setCenter","newCenter","oldCenter","lastSetCenter","lat","lng","panTo","onBeforeUnmount","computed","width","height","draggable","icon","zIndexOffset","setDraggable","dragging","enable","disable","latLngSync","event","latlng","setLatLng","oldLatLng","getLatLng","getElement","html","innerHTML","newIcon","setIcon","markerSetup","marker","latLngs","smoothFactor","noClip","polylineProps","content","gridLayerProps","tms","subdomains","detectRetina","url","gridLayerOptions","gridLayerMethods","gridLayerSetup","tileLayerSetup","tileLayer"],"sourceRoot":""}